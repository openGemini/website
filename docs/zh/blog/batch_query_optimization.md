---
blog: true
title: openGemini：批量查询优化
pubDate: '2023-11-24'
author: 陈志
abstract: 本文介绍了什么是批量查询，以及批量查询串行执行带来性能问题，openGemini充分利用了Go语言强大的并发处理能力，对串行查询进行并发改造，提出的自适应并行查询任务调度器，以解决串行查询的性能问题。
cover: /images/cover/batch_query_optimization.png
recommend: 0
# category: 技术解读 公司动态 案例实践 社区动态 观点洞察
category: 技术解读
tag: 性能优化
---

## **批量查询优化的背景**

### **♦ 什么是批量查询？**

批量查询是将多条查询语句打包，一次发给数据库，数据库内部逐条执行，将结果汇总后返回客户端，我们称之为批量查询。

### **♦** **批量查询场景**

![img](/images/docs_img/05b7314d8123ef3ef0457d1367d17dd7.png)

在运维监控场景中，监控面板存在非常多的图表（上图仅仅是其中一部分），这些图表会定期查询更新数据，一部分图表可能由上百个查询结果绘制而成，如果所有图表中的查询全部独立发送到时序数据库，这将导致并发激增，客户端和数据库都无法支撑，因此只能把查询语句打包给到时序数据库，由数据库批量执行并返回结果数据。

![img](/images/docs_img/df9bac1207eba90f60fdb6fb0dfe6141.png)

使用批量查询时，查询语句之间需要用分号“;”进行分割，如下

```
SELECT disk_usage FROM table; SELECT disk_io FROM table；…
```

### **♦** **批量查询引发的问题**

当批量查询到来时，openGemini 通常是依次执行每条查询语句，执行完成后再执行下一条，因此无法利用 openGemini 的并发能力。当批量查询语句很多时，往往查询周期较长，无法满足性能诉求，因此产生了优化的需求。

## **优化方法**

openGemini 的内核由 Golang 实现，其 GMP 模型高度支持并发性，非常适合将串行改为并行。

-   **Golang GMP 模型**

![img](/images/docs_img/9d97b161eff14901e87c3bc561a37b44.png)

KSE 是 Kernel Scheduling Entity 的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。

**G-M-P 分别代表：**

G - Goroutine，Go 协程，是参与调度与执行的最小单位

M - Machine，指的是系统级线程，由系统调用产生

P - Processor，指的是逻辑处理器，P 关联了的本地可运行 G 的队列，最多可存放 256 个 G。

因此针对串行查询的性能问题，可以利用 Golang 的 GMP 模型的优势，进行并行化改造。

-   **openGemini 自适应并行查询任务调度器**

![img](/images/docs_img/1300498aae8905905eff0c1c5f555555.png)

openGemini 自适应并行查询任务调度器将根据机器规格，创建相应数量的 goroutine 用于并行执行查询命令，例如对于 4U 的机器，并发度为 4（效率最高），如果 12 条批量查询语句，每次并发执行 4 条查询语句，仅需要 3 轮就可以执行完成，而在没有加入自适应并行查询任务调度器之前，12 条查询语句要执行 12 次，无法充分利用 CPU 的并发能力。

相关源码文件：open_src/Influx/query/executor.go

具体方法：

```
func executeParallelQuery()
```

## **优化后性能参考**

**测试规格：（12 节点集群，单节点规格 32U128G）**

| 查询场景                                                                            | 并发量 | 平均时延(ms) |
| ----------------------------------------------------------------------------------- | ------ | ------------ |
| 批量查询 1 小时范围 50 条时间线，1min 粒度平均值聚合，背景压力 2650 万时间线        | 100    | 48           |
| 200                                                                                 | 53     |              |
| 300                                                                                 | 64     |              |
| 500                                                                                 | 100    |              |
| 批量查询 30 分钟范围内 100 条时间线，按 1min 粒度平均值聚合；背景压力 2650 万时间线 | 100    | 59           |
| 200                                                                                 | 66     |              |
| 400                                                                                 | 108    |              |

openGemini 采用该优化的版本为 v1.1.0，可在配置文件中打开该功能开关即可。

//如下是代码块

```
[http]
parallel-query-in-batch-enabled = true
```

## **总结**

本文介绍了什么是批量查询，以及批量查询串行执行带来性能问题，openGemini 充分利用了 Go 语言强大的并发处理能力，对串行查询进行并发改造，提出的自适应并行查询任务调度器，以解决串行查询的性能问题。希望本文对大家了解 openGemini 有所帮助。

---

**更多资讯可关注 openGemini 公众号和视频号。如果您对 openGemini 相关技术感兴趣，欢迎到社区与大家进行相关技术讨论。**

<div align=center>
<img src="/images/qrcode.jpg" >
</div>
